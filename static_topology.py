#!/usr/bin/env python
# -*- coding:utf-8 -*-

# Copyright 2012 James McCauley
#
# This file is part of POX.
#
#l POX is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# POX is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with POX.  If not, see <http://www.gnu.org/licenses/>.
"""
This Program is prototype of master thesis toru-tu@naist

Dependes on openflow.discovery
Works with openflow.spanning_tree

"""

from pox.core import core
import pox.openflow.libopenflow_01 as of
import pox.lib.packet as pkt
from pox.lib.revent import *
from pox.lib.recoco import Timer
from collections import defaultdict
from eco_discovery import Discovery
from pox.lib.util import dpidToStr
from pox.lib.util import strToDPID
from pox.lib.addresses import IPAddr,EthAddr
from PathInstalled import *
import networkx as nx
import threading
import time
import L2L3
import os
import random
import csv
import itertools
from monitor_thread import *
from monitor_linkpacking_thread import *
# experimental parameter is here.
from variable_parameter import *

log = core.getLogger()

# ip_mac -map
ip_mac = L2L3.L2L3()

# physical topology graph
phy_topology = nx.DiGraph()

# low power subnet generated by phy_topology
eco_subnet = nx.DiGraph()

# ethaddr -> (switch,port)
mac_map = {}

# bin packing map [sw1][sw2]->[flow id]
content_map = defaultdict(lambda:defaultdict(lambda:list()))

# Thread class
# output number of edges and nodes to stdout 
monitor  = None
monitor_link  = None

# give each flow using flow identification
flow_id = -1
# [flow_id]-> size
flow_map = {}

def _calc_packing(p):
    contention_list_ = []
    
    for s1,s2 in zip(p[:-1],p[1:]):
        contention_ = 0
        # f_list_ = map(int,content_map[s1][s2])
        f_list_ = content_map[s1][s2]
        for f in f_list_:
            contention_ += flow_map[f]
        contention_list_.append(contention_)

    result_packing_ = BANDWIDTH -max(contention_list_)
    return result_packing_

def _get_raw_path(src,dst, flow_size, check_connectivity=0):
    def get_ecmp_path_list(topology,src,dst):
        simple_paths_= list(nx.all_shortest_paths(topology,source=dpidToStr(src.dpid),
                            target=dpidToStr(dst.dpid)))
        return simple_paths_
    def get_path_list(topology,src,dst):
        shortest_path_len_ = nx.dijkstra_path_length(topology,dpidToStr(src.dpid),dpidToStr(dst.dpid))
        simple_paths_ = list(nx.all_simple_paths(topology,source=dpidToStr(src.dpid),
                                             target=dpidToStr(dst.dpid), cutoff = shortest_path_len_ + CUTOFF))
        return simple_paths_

    global eco_subnet
    global phy_topology
    log.debug("src.dpid: %s  dst.dpid: %s",dpidToStr(src.dpid),dpidToStr(dst.dpid))

    if check_connectivity == CHECK_CONNECTIVITY:
        path_list_ = get_ecmp_path_list(eco_subnet,src,dst)
    else:
        path_list_ = get_ecmp_path_list(phy_topology,src,dst)
    
    # get max contention value each path
    bin_content_ =[]
    for i in range(len(path_list_)):
        bin_content_.append(_calc_packing(path_list_[i]))

    if max(bin_content_) <= 0:
        log.debug("All path cannot assign flow:Search other flow")
        path_list_ = get_path_list(phy_topology,src,dst)
        bin_content_ =[]
        for i in range(len(path_list_)):
            bin_content_.append(_calc_packing(path_list_[i]))
    
    log.debug("number_of path = %s" % len(bin_content_))
    log.debug("each path bin_content_ = %s" % bin_content_)
    
    # binに割り当て可能か確認する
    if check_connectivity == CHECK_CONNECTIVITY:
        path_select_index_ = random.randint(0,(len(path_list_)-1))
        return path_list_[path_select_index_]
    else:
        for i in range(len(path_list_)):
            if bin_content_[i] - flow_size < 0:
                continue
            else:
                return path_list_[i]
   
def _check_path(src,dst):
    global eco_subnet
    global phy_topology

    if eco_subnet.has_edge(src,dst) == False:
        if phy_topology.has_edge(src,dst) == False :
            return False
        else:
            forward_port_ = phy_topology[src][dst]['port']
            back_port_ = phy_topology[dst][src]['port']
            eco_subnet.add_edge(src, dst, port = forward_port_)
            eco_subnet.add_edge(dst, src, port = back_port_)
            log.info("add_edge to eco_subnet %s -> %s" % (src,dst))
    return True
    

def _check_switch(p):
    global eco_subnet
    global phy_topology
    log.debug("IN _init_check_switch")
    #for i in range(len(p) -1):         
    for i in range(len(p)):
        if eco_subnet.has_node(p[i]) is False:
            if phy_topology.has_node(p[i]) is False : return False
            else:
                log.info("add_node to eco_subnet %s" % phy_topology.node[p[i]])
                sw_instance_ = phy_topology.node[p[i]]['switch']
                eco_subnet.add_node(p[i], switch = sw_instance_)
    return True

def _init_check_switch(p):
    global eco_subnet
    global phy_topology
    for i in range(len(p)):
        log.debug("IN _init_check_switch")
        if eco_subnet.has_node(p[i]) is False:
            if phy_topology.has_node(p[i]) is False : return False
            else:
                log.debug("INIT:add_node to eco_subnet %s" % phy_topology.node[p[i]])
                sw_instance_ = phy_topology.node[p[i]]['switch']
                eco_subnet.add_node(p[i], switch = sw_instance_)
    return True
    
def _get_path(src,dst,final_port,flow_size = ITEM_SIZE,check_connectivity=UNCHECK_CONNECTIVITY):
    global flow_id
    global eco_subnet
    global phy_topology

    path_= []
    if src == dst:
        path_ = [str(src)]
    else:
        # path <- return path list src to dst express str(dpid)
        path_ = _get_raw_path(src, dst, flow_size, check_connectivity)
        if path_ is None: return None
        
    if _check_switch(path_)==False:
        exit 

    r_ = []
    # Create tuple ((sw,port),()....)
    for s1,s2 in zip(path_[:-1],path_[1:]):
        if _check_path(s1,s2) == False: exit     
        port_ = eco_subnet[s1][s2]['port']
        r_.append((s1,port_))
        content_map[s1][s2].append(flow_id)
        content_map[s2][s1].append(flow_id)

    r_.append((path_[-1], final_port))

    #    assert _check_path(r)

    return r_

def _install(switch,port,match,buf=-1):
    # install switch flow_table
    # configure flow_entry timeout here!!
    msg_ = of.ofp_flow_mod()
    msg_.match = match
    msg_.idle_timeout = IDLE_TIMEOUT
    msg_.hard_timeout = HARD_TIMEOUT
    #msg_.actions.append(of.ofp_action_output(port = port))
    #msg_.buffer_id = buf
    switch.connection.send(msg_)
    
def _install_path(p, match, buffer_id=-1):
    for s,port in p[1:]:
        sw = eco_subnet.node[s]['switch'] 
        _install(sw, port, match)

    src_sw = eco_subnet.node[p[0][0]]['switch']
    _install(src_sw,p[0][1], match, buffer_id)
    
    event = PathInstalled(p)
    core.static_topology.raiseEvent(event)
    
def install_path(src_sw, dst_sw, last_port, match,flow_size=ITEM_SIZE,
                 check_connectivity=UNCHECK_CONNECTIVITY):
    # dst_sw is switch instance
    # print 'install_path', self,dst_sw
    global flow_id
    p = _get_path(src_sw,dst_sw,last_port, flow_size, check_connectivity)
    if p is None:
        log.warning("Can't get from %s to %s", match.dl_src, match.dl_dst)

    log.debug('will install this path:%s' %p)
    _install_path(p,match)

    flow_id += 1
    if (check_connectivity == UNCHECK_CONNECTIVITY):
        flow_map[flow_id]=flow_size + MARGIN_SIZE
    else:
        flow_map[flow_id]=flow_size
    log.debug("Installing path for %s -> %s %04x (%i hops)",
              match.dl_src,match.dl_dst,match.dl_type,len(p))

def hostip_to_edge_dpid(ip_address):
    dot_divided_ = ip_address.split('.')
    host_address_ = int(dot_divided_[-1])
    dpid = (POD_NUM + POD_NUM**3/4 + POD_NUM**2/2 + 1)+host_address_/(POD_NUM/2)
    return dpid

def static_path_cal(tr_matrix):
    global ip_mac
    
    log.debug("In static path calcuration")
    # トラフィックマトリックスをもとにして、パスをinstallする
    for src,dst in itertools.product(ip_mac,ip_mac):
        flow_size = tr_matrix[src][dst]
        if flow_size == 0:
            continue
        else:
            log.debug("src:%s, dst:%s",src,dst)
            # create match object
            match = of.ofp_match(dl_type = pkt.ethernet.IP_TYPE,dl_vlan= 65535,
                                 dl_vlan_pcp=0,dl_src=src[1],dl_dst=dst[1])
                                 
            match.nw_src = (IPAddr(src[0]))
            match.nw_dst = (IPAddr(dst[0]))
            match.dl_src = (EthAddr(src[1]))
            match.dl_dst = (EthAddr(dst[1]))
            #dpid_src = hostip_to_edge_dpid(src[0])
            #dpid_dst = hostip_to_edge_dpid(dst[0])
            
            # エッジスイッチの呼び出し
            #src_loc = mac_map[dpidToStr(dpid_src)]
            #dst_loc = mac_map[dpidToStr(dpid_dst)]
            src_loc = mac_map[src[1]]
            dst_loc = mac_map[dst[1]]
            
            install_path(src_loc[0], dst_loc[0], dst_loc[1], match,flow_size)
        
    log.debug("End static path calcuration")

def ensure_connectivity(tr_matrix):
    global ip_mac
    log.debug("In ensure connectivity")

    for src,dst in itertools.product(ip_mac,ip_mac):
        flow_size = tr_matrix[src][dst]
        if flow_size != 0:
            continue
        else:
            match = of.ofp_match(dl_type = pkt.ethernet.IP_TYPE,dl_vlan= 65535,
                                 dl_vlan_pcp=0)
            match.nw_src =(IPAddr(src[0]))
            match.dl_src = (EthAddr(src[1]))
            match.nw_dst=(IPAddr(dst[0]))
            match.dl_dst = (EthAddr(dst[1]))
            
            # エッジスイッチの呼び出し
            src_loc = mac_map[src[1]]
            dst_loc = mac_map[dst[1]]
            install_path(src_loc[0], dst_loc[0], dst_loc[1], match,flow_size=0,
                             check_connectivity=CHECK_CONNECTIVITY)
    log.debug("End ensure connectivity")
    
def _pickup_element_from_source(source_file,t, delta_t = 0.0):
    element_list = []
    #print source_file.name
    for row in csv.reader(source_file):
        if(row[0]=='start_epoch'): continue
        #print 'start_time',row[0]
        start_time = float(row[0])
        
        end_time = start_time+float(row[1])
        #print 'end_time %f' % end_time
        if(end_time - t > 0  and t - start_time>0):
            element_list.append(row)

    return element_list

def gen_traffic_matrix(time,delta_t=0.0):
    global ip_mac
    
    raw_tr_list = []
    tr_matrix = defaultdict(lambda:defaultdict(lambda:0))
    
    # get raw  traffic info from file
    for root, dirs, files in os.walk(DIR):
        for file_name in files:
            f = open(DIR+'/'+file_name)
            raw_list = _pickup_element_from_source(f,time,delta_t=delta_t)
            for element in raw_list:
                raw_tr_list.append(element)
            f.close()

    for i in range(len(raw_tr_list)):
        src_ip = raw_tr_list[i][2]
        dst_ip = raw_tr_list[i][3]
        src_mac = ip_mac.get_mac_address(src_ip)
        dst_mac = ip_mac.get_mac_address(dst_ip)
        tr_matrix[(src_ip,src_mac)][(dst_ip,dst_mac)]+= ITEM_SIZE
        #tr_matrix[(dst_ip,dst_mac)][(src_ip,src_mac)]+= ITEM_SIZE

    log.debug("End gen_traffic_matrix")
    return tr_matrix

def create_ip_mac_map():
    global ip_mac
    for i in range(1,POD_NUM**3/4+1):
        mac = ''
        if i < 16:
            mac = '00:00:00:00:00:0' + '%x' % i
        else :
            mac = '00:00:00:00:00:' + '%x' % i
        ip = '10.0.0.'+ '%d' % i
        ip_mac.set_entry(ip,mac)

def create_mac_map():
    global mac_map
    global phy_topology
    host_num = 1
    for host_num in range(1,POD_NUM**3/4+1):
        if host_num < 16:
            dl_src = "00:00:00:00:00:0" + '%x' % host_num
        else:
            dl_src = "00:00:00:00:00:" + '%x' % host_num
        port = (host_num-1) % (POD_NUM/2) + POD_NUM/2
        switch_dpid =(POD_NUM+POD_NUM**3/4+POD_NUM**2/2 + 1)+(host_num-1)/(POD_NUM/2)
        sw_instance_ = phy_topology.node[dpidToStr(switch_dpid)]['switch']
        mac_map[dl_src] =(sw_instance_,port)
        
        
def calc_topology():
    global eco_subnet
    global content_map
    global flow_map
    global flow_id
    
    eco_subnet.clear()
    content_map.clear()
    flow_map.clear()
    flow_id = -1
    time = BASE_TIME
    tr_matrix = gen_traffic_matrix(time)
    static_path_cal(tr_matrix)
    ensure_connectivity(tr_matrix)
    monitor_link = monitor_linkpacking_thread(log,content_map,flow_map,eco_subnet)
    monitor_link.start()
    
class Switch(EventMixin):
    def __init__(self):
        self.connection = None
        self.ports = None
        self.dpid = None
        self._listeners = None

    def __repr__(self):
        return dpidToStr(self.dpid)

    
    def _handle_PacketIn(self, event):
        global flow_id
        global eco_subnet

        def flood():
            """ Flooding the packet"""
            msg_ = of.ofp_packet_out()
            msg_.actions.append(of.ofp_action_output(port = of.OFPP_FLOOD))
            msg_.buffer_id = event.ofp.buffer_id
            msg_.in_port = event.port
            self.connection.send(msg_)
        
        def drop():
            """Kill the buffer"""
            if event.ofp.buffer_id != -1:
                msg_ = of.ofp_packet_out()
                msg_.buffer_id = event.ofp.buffer_id
                event.ofp.buffer_id = -1
                msg_.in_port = event.port
                self.connection.send(msg_)            
        packet = event.parsed
        if packet.src.isMulticast() == True:
            
            flood()
            return
        else :
            loc = (self,event.port)
            oldloc = mac_map.get(packet.src)
            
            if packet.type == packet.LLDP_TYPE:
                drop()
                return
            log.debug("packet:src= %s packet:dst= %s / (loc,oldloc)= (%s,%s) ",packet.src,packet.dst,loc,oldloc)
            
            if oldloc is None:
                if packet.src.isMulticast() == False:
                    mac_map[packet.src] = loc #learn position for ethaddr
                    log.debug("Learned %s at %s.%i",packet.src, loc[0],loc[1])
                    
            drop()
            return
        
        # loc = (switch, port)
        # elif oldloc != loc:
        #     # ethaddr seen at different place
        #     # eco_subnet[] is MultiGraph().neighbors(n)
        #     # input: node Returns: list node
        #     if eco_subnet.has_node(dpidToStr(loc[0].dpid)) == True:
        #         if eco_subnet[dpidToStr(loc[0].dpid)].has_key(loc[1])==False:
        #             # New place is another plain port (probably)
        #             log.debug("%s moved from %s.%i to %s.%i?", packet.src,
        #                     dpidToStr(oldloc[0].connection.dpid), oldloc[1],
        #                     dpidToStr(   loc[0].connection.dpid),    loc[1])
        #             if packet.src.isMulticast() == True:
        #             #if packet.src.isMulticast() == False:
        #                 mac_map[packet.src] = loc
        #                 log.debug("Learned %s at %s.%i",packet.src, loc[0],loc[1])
        #         elif packet.dst.isMulticast() == False:
        #             log.warning("Packet from %s arrived at %s.%i without flow",
        #                             packet.src, dpidToStr(self.dpid), event.port)

        # if packet.dst.isMulticast():
        #     log.debug("flood multicast from %s", packet.src)
        #     flood()
        # else:
        #     if packet.dst not in mac_map:
        #         log.debug("%s unknown --drop", packet.dst,)
        #         drop()
        #     else:
        #         flow_id += 1
        #         dest = mac_map[packet.dst]
        #         match = of.ofp_match.from_packet(packet)
        #         flow_map[flow_id]=ITEM_SIZE
        #         log.debug('flow_id %d ITEM_SIZE=%d' % (flow_id,flow_map[flow_id]))
        #         self.install_path(dest[0],dest[1],match,event)
                
        
    def disconnect(self):
        if self.connection is not None:
            log.debug("Disconnect %s " % (self.connection,))
            self.connection.removeListeners(self._listeners)
            self.connection = None
            self._listeners = None

    def connect(self,connection):
        if self.dpid is None:
            self.dpid = connection.dpid
        assert self.dpid == connection.dpid

        if self.ports is None:
            self.ports = connection.features.ports
        self.disconnect()
        log.debug("Connect %s" % (connection,))
        self.connection = connection
        self._listeners = self.listenTo(connection)

    def _handle_ConnectionDown(self, event):
        self.disconnect()

class static_topology(EventMixin):
    global phy_topology
    global eco_subnet

    _eventMixin_events = set([
        PathInstalled,
        ])

    def __init__(self):
        self.listenTo(core.openflow, priority=0)
        self.listenTo(core.openflow_discovery)

    def _handle_LinkEvent(self,event):
        global eco_subnet
        global phy_topology
        def flip(link):
            return Discovery.Link(link[2],link[3], link[0],link[1])

        l = event.link
        string_dpid1 = dpidToStr(l.dpid1)
        string_dpid2 = dpidToStr(l.dpid2)

        # clear all entry of switch
        clear = of.ofp_flow_mod(match=of.ofp_match(),command=of.OFPFC_DELETE)
        # index = str(dpid) , sw=Switch 
        for index,sw in phy_topology.nodes_iter(data=True):
            sw.values()[0].connection.send(clear)
        #flow_map.clear()
        
        if event.removed:
            if l.dpid2 in phy_topology[string_dpid1]:
                phy_topology.remove_edge(string_dpid1, string_dpid2)
            if l.dpid1 in phy_topology[string_dpid2]:
                phy_topology.remove_edge(string_dpid2, string_dpid1)

            for ll in core.openflow_discovery.adjacency:
                if ll.dpid1 == l.dpid1 and ll.dpid2 == l.dpid2:
                    if flip(ll) in core.openflow_discovery.adjacency:
                        phy_topology.add_edge(string_dpid1, string_dpid2,port=ll.port1)
                        phy_topology.add_edge(string_dpid2, string_dpid1,port=ll.port2)
                        break
        else:
            # もし、既に接続済みなら無視できる
            # 未接続ならば、
            if phy_topology.has_edge(string_dpid1, string_dpid2) == False:
                if flip(l) in core.openflow_discovery.adjacency:
                    phy_topology.add_edge(string_dpid1, string_dpid2, port=l.port1)
                    phy_topology.add_edge(string_dpid2, string_dpid1, port=l.port2)
                 
    def _handle_ConnectionUp(self, event):
        str_event_dpid = dpidToStr(event.dpid)
        if phy_topology.has_node(str_event_dpid) == False:
            # New Switch is appeared
            sw = Switch()
            phy_topology.add_node(str_event_dpid,switch=sw)
            sw.connect(event.connection)
            log.debug("node %s" % phy_topology.node)
        else:
            log.debug("event dpid is %s", str_event_dpid)
            sw = phy_topology.node[str_event_dpid]['switch']
            sw.connect(event.connection)

# def create_eco_subnet():
#     global phy_topology
    
#     switchNum = POD_NUM**3/4 + 1
#     p_edge_top = POD_NUM**3/4 + 1 + POD_NUM + POD_NUM**2/2
#     p_edge_bottom = p_edge_top + POD_NUM**2/2
    
#     all_path = nx.shortest_path(phy_topology,dpidToStr(switchNum))
#     for edge_num in range(p_edge_top,p_edge_bottom):
#         path = all_path[dpidToStr(edge_num)]
#         _init_check_switch(path)
#         for s1,s2 in zip(path[:-1],path[1:]):
#             if _check_path(s1,s2)==False:
#                 exit                   

def launch():
    global eco_subnet
    global phy_topology
    global monitor
    global monitor_link
    global mac_map
    if 'openflow_discovery' not in core.components:
        import pox.openflow.Discovery as discovery
        core.registerNew(discovery.Discovery)

    core.registerNew(static_topology)
    create_ip_mac_map()
    monitor = monitor_thread(log,eco_subnet,phy_topology,5)
    monitor.start()
    Timer(20,create_mac_map)
    #log.debug("%s", mac_map)
    Timer(45,calc_topology)
